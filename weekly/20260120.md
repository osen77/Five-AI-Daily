# [五条0113] 命令行设计：下一个UX新战场
发布日期：2026/01/13

这是 [Command Line Interface Guidelines](https://clig.dev/) 的中文翻译，基于 [CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/) 协议[开源](https://github.com/onevcat/cli-guidelines)。本指南旨在帮助你编写更好的命令行程序，以传统 UNIX 原则为基础，并针对现代需求进行了更新。

**Aanand Prasad**  
 Squarespace 工程师，Docker Compose 联合创建者。  
[@aanandprasad](https://twitter.com/aanandprasad)

**Ben Firshman**  
[Replicate](https://replicate.ai/) 联合创建者，Docker Compose 联合创建者。  
[@bfirsh](https://twitter.com/bfirsh)

**Carl Tashian**  
[Smallstep](https://smallstep.com/) 越野工程师，Zipcar 首位工程师，Trove 联合创始人。  
[tashian.com](https://tashian.com/)[@tashian](https://twitter.com/tashian)

**Eva Parish**  
 Squarespace 技术文档工程师，O'Reilly 撰稿人。  
[evaparish.com](https://evaparish.com/)[@evpari](https://twitter.com/evpari)

设计：[Mark Hurrell](https://mhurrell.co.uk/)。感谢 Andreas Jansson 的早期贡献，以及 Andrew Reitz、Ashley Williams、Brendan Falk、Chester Ramey、Dj Walker-Morgan、Jacob Maine、James Coglan、Michael Dwan 和 Steve Klabnik 审阅草稿。

中文翻译：[Wei Wang （onevcat）](https://onevcat.com) 和他的一众 AI 助手。

如果你想讨论本指南或 CLI 设计，欢迎[加入我们的 Discord](https://discord.gg/EbAW5rUCkE)。

在 1980 年代，如果你想让个人电脑为你做些什么，你需要知道在面对 或 时该输入什么。帮助来自厚重的螺旋装订手册。错误信息晦涩难懂。那时还没有 Stack Overflow 可以拯救你。但如果你有幸能上网，你可以从 Usenet 获得帮助——一个早期的互联网社区，里面都是和你一样沮丧的人。他们要么帮你解决问题，要么至少提供一些精神支持和同病相怜的慰藉。`C:\>` `~$`

四十年后，计算机变得更加普及，但这往往是以牺牲底层终端用户控制权为代价的。在许多设备上，根本没有命令行访问权限，部分原因是这与围墙花园和应用商店的商业利益相悖。

今天大多数人不知道命令行是什么，更不知道为什么要费心使用它。正如计算机先驱 Alan Kay 在 [2017 年的一次采访](https://www.fastcompany.com/40435064/what-alan-kay-thinks-about-the-iphone-and-technology-now)中所说：“因为人们不理解计算是什么，他们以为 iPhone 就是计算的全部，这种错觉就像以为玩《劲舞团》，就等于会跳真正的街舞一样。”

Kay 所说的“真正的街舞”并不完全是指 CLI。他谈的是编程计算机的方式，这些方式提供了 CLI 的能力，并超越了在文本文件中编写软件的范畴。Kay 的追随者们相信，我们需要突破几十年来一直生活其中的基于文本的局部最优。

想象一下，我们会以完全不同方式进行计算机编程，这样的未来令人兴奋。即使在今天，电子表格依然是迄今为止最流行的编程语言，而无代码运动也在快速兴起，试图取代对优秀程序员的部分强烈需求。

然而，尽管命令行有着几十年的陈旧约束和莫名其妙的怪癖，它仍然是计算机中最_通用_的角落。它让你能够揭开帷幕，看到真正发生的事情，并以 GUI 无法提供的复杂度和深度与机器进行创造性的交互。它几乎在任何笔记本电脑上都可用，任何想学习的人都能使用。它可以交互式使用，也可以自动化。而且，它不像系统的其他部分那样变化迅速。它的稳定性具有创造性价值。

所以，既然我们还拥有它，我们就应该努力最大化它的实用性和可访问性。

自那些早期以来，我们编程计算机的方式发生了很大变化。过去的命令行是_机器优先_的：不过是脚本平台之上的一个 REPL。但随着通用解释型语言的蓬勃发展，shell 脚本的角色已经缩小。今天的命令行是_人类优先_的：一个基于文本的用户界面，提供对各种工具、系统和平台的访问。过去，编辑器在终端内部——今天，终端同样经常是编辑器的一个功能。而且出现了大量类似 的多功能命令。命令中嵌套命令，以及执行完整工作流而非原子功能的高级命令。`git`

受传统 UNIX 哲学的启发，出于对鼓励更令人愉悦和更易访问的 CLI 环境的兴趣，并以我们作为程序员的经验为指导，我们决定是时候重新审视构建命令行程序的最佳实践和设计原则了。

命令行万岁！

本文档涵盖高层设计哲学和具体指南两方面。指南部分篇幅更多，因为作为实践者，我们的哲学就是不要过度哲学化。我们相信通过示例学习，所以提供了大量例子。

本指南不涉及像 emacs 和 vim 这样的全屏终端程序。全屏程序是小众项目——我们中很少有人会处于需要设计此类程序的位置。

本指南对编程语言和工具保持中立。

本指南适合谁？

* 如果你正在创建一个 CLI 程序，并且正在寻找其 UI 设计的原则和具体最佳实践，本指南适合你。
* 如果你是一名专业的“CLI UI 设计师”，那太棒了——我们很想向你学习。
* 如果你想避免那些违背 40 年 CLI 设计惯例的明显失误，本指南适合你。
* 如果你想用程序的良好设计和有帮助的帮助信息来取悦用户，本指南绝对适合你。
* 如果你正在创建 GUI 程序，本指南不适合你——尽管如果你决定阅读它，你可能会学到一些 GUI 反模式。
* 如果你正在设计一个沉浸式的、全屏的 CLI 版 Minecraft，本指南不适合你。（但我们迫不及待想看到它！）

以下是我们认为良好 CLI 设计的基本原则。

传统上，UNIX 命令是在假设它们主要被其他程序使用的前提下编写的。它们与编程语言中的函数比与图形应用程序有更多共同点。

今天，即使许多 CLI 程序主要（甚至完全）由人类使用，它们的交互设计仍然承载着过去的包袱。是时候甩掉这些包袱了：如果一个命令主要由人类使用，它就应该首先为人类设计。

[原始 UNIX 哲学](https://en.wikipedia.org/wiki/Unix%5Fphilosophy)的核心原则是：具有清晰接口的小型、简单程序可以组合起来构建更大的系统。与其在这些程序中塞入越来越多的功能，不如让程序足够模块化，以便根据需要重新组合。

在过去，管道和 shell 脚本在程序组合过程中扮演着关键角色。它们的角色可能随着通用解释型语言的兴起而减弱，但它们肯定没有消失。更重要的是，大规模自动化——以 CI/CD、编排和配置管理的形式——已经蓬勃发展。使程序可组合与以往一样重要。

幸运的是，UNIX 环境中长期建立的惯例，正是为此目的而设计的，今天仍然帮助着我们。标准输入/输出/错误、信号、退出码和其他机制确保不同程序能够很好地协作。纯文本、基于行的文本很容易在命令之间管道传输。JSON，一个更近期的发明，在我们需要时提供了更多结构，让我们更容易将命令行工具与 Web 集成。

无论你构建什么软件，你都可以绝对确定人们会以你没有预料到的方式使用它。你的软件_将_成为更大系统的一部分——你唯一的选择是它是否会成为一个行为良好的部件。

最重要的是，为可组合性设计不需要与人类优先设计相矛盾。本文档中的许多建议都是关于如何同时实现这两者的。

终端的惯例已经刻入我们的手指。我们必须通过学习命令行语法、标志、环境变量等来支付前期成本，但这在长期效率上得到了回报……只要程序是一致的。

在可能的情况下，CLI 应该遵循已经存在的模式。这就是让 CLI 直观和可猜测的原因；这就是让用户高效的原因。

话虽如此，有时一致性与易用性冲突。例如，许多长期存在的 UNIX 命令默认不输出太多信息，这可能会让不太熟悉命令行的人感到困惑或担忧。

当遵循惯例会损害程序的可用性时，可能是时候打破它了——但这样的决定应该谨慎做出。

终端是一个纯信息的世界。你可以说信息就是界面——而且，就像任何界面一样，信息往往太多或太少。

当一个命令挂起几分钟而用户开始怀疑它是否坏了时，命令就是说得太少了。当一个命令倾倒出页面又页面的调试输出，将真正重要的东西淹没在一片松散的碎屑海洋中时，命令就是说得太多了。最终结果是一样的：缺乏清晰度，让用户困惑和恼火。

要达到这种平衡可能非常困难，但如果软件要赋能并服务其用户，这绝对是至关重要的。

在让功能可发现方面，GUI 占据优势。你能做的一切都摆在屏幕前，所以你不需要学习任何东西就能找到你需要的，甚至可能发现你不知道可以做的事情。

人们假设命令行界面与此相反——你必须记住如何做一切事情。1987 年发布的原版 [Macintosh Human Interface Guidelines](https://archive.org/details/applehumaninterf00appl) 推荐"看和指（而不是记住和输入）"，好像你只能选择其中之一。

这些事情不必相互排斥。使用命令行的效率来自于记住命令，但没有理由命令不能帮助你学习和记忆。

可发现的 CLI 有完整的帮助文本，提供大量示例，建议接下来运行什么命令，建议出错时该怎么做。有很多想法可以从 GUI 中借鉴，使 CLI 更容易学习和使用，即使对于高级用户也是如此。

_引用：The Design of Everyday Things (Don Norman)，Macintosh Human Interface Guidelines_

GUI 设计，尤其在早期，大量使用_隐喻_：桌面、文件、文件夹、回收站。这很有意义，因为计算机仍在试图引导自己进入合法性。隐喻的实现便利性是 GUI 相对于 CLI 的巨大优势之一。然而，讽刺的是，CLI 一直体现着一个意外的隐喻：它是一场对话。

除了最简单的命令，运行一个程序通常涉及不止一次调用。通常，这是因为很难第一次就做对：用户输入一个命令，得到一个错误，修改命令，得到一个不同的错误，如此反复，直到成功。这种通过反复失败学习的模式就像用户与程序之间的对话。

然而，试错并不是唯一的对话式交互类型。还有其他类型：

* 运行一个命令来设置工具，然后学习运行哪些命令来实际开始使用它。
* 运行多个命令来设置一个操作，然后运行最后一个命令来执行它（例如，多个 ，然后是 ）。`git add` `git commit`
* 探索一个系统——例如，做大量的 和 来了解目录结构，或者用 和 来探索文件的历史。`cd` `ls` `git log` `git show`
* 在实际运行之前对复杂操作进行预演。

承认命令行交互的对话性质意味着你可以将相关技术应用于其设计。当用户输入无效时，你可以建议可能的更正，当用户正在进行多步骤过程时，你可以让中间状态清晰可见，在他们做一些可怕的事情之前，你可以为他们确认一切看起来都很好。

无论你是否有意为之，用户都在与你的软件对话。在最坏的情况下，这是一场敌对的对话，让他们感到愚蠢和怨恨。在最好的情况下，这是一次愉快的交流，让他们带着新获得的知识和成就感快速前进。

健壮性既是客观属性也是主观属性。软件当然应该_是_健壮的：意外输入应该被优雅地处理，操作应该尽可能是幂等的，等等。但它也应该_感觉_健壮。

你希望你的软件感觉不会散架。你希望它感觉即时和响应，就好像它是一台大型机械机器，而不是一个脆弱的塑料"软开关"。

主观的健壮性需要关注细节，并认真思考什么可能出错。它是很多小事情的集合：让用户了解正在发生什么，解释常见错误的含义，不打印看起来可怕的堆栈跟踪。

作为一般规则，健壮性也可以来自保持简单。大量的特殊情况和复杂代码往往使程序变得脆弱。

命令行工具是程序员的创意工具包，所以它们应该用起来很愉快。这并不意味着把它们变成视频游戏，或使用大量 emoji（尽管 emoji 本身没有什么问题 😉）。它意味着给用户一种感觉：你站在他们这边，你希望他们成功，你已经仔细考虑过他们的问题以及如何解决它们。

没有一份可以保证他们有这种感觉的行动清单，尽管我们希望遵循我们的建议会让你走完一部分路程。取悦用户意味着在每一个转折点都_超越他们的期望_，而这始于同理心。

终端的世界是一团混乱。不一致性无处不在，减慢我们的速度，让我们质疑自己。

然而不可否认的是，这种混沌一直是力量的源泉。终端，像一般的 UNIX 派生计算环境一样，对你能构建什么施加的约束很少。在这个空间里，各种各样的发明蓬勃发展。

讽刺的是，本文档恳请你遵循现有模式，同时又给出了与数十年命令行传统相矛盾的建议。我们和任何人一样，都在打破规则。

你也可能有一天不得不打破规则。要有意图和目的清晰地这样做。

> “当一个标准明显损害生产力或用户满意度时，就放弃它。” — Jef Raskin，[The Humane Interface](https://en.wikipedia.org/wiki/The%5FHumane%5FInterface)

这是一组可以让你的命令行程序变得更好的具体事项。

第一部分包含你需要遵循的基本事项。如果这些做错了，你的程序要么难以使用，要么是一个糟糕的 CLI 公民。

其余的是锦上添花。如果你有时间和精力添加这些东西，你的程序将比一般程序好得多。

理念是，如果你不想对程序的设计思考太多，你不必：只需遵循这些规则，你的程序可能会很好。另一方面，如果你已经思考过并确定某条规则对你的程序不适用，那也没问题。（没有什么中央机构会因为你没有遵循任意规则而拒绝你的程序。）

另外——这些规则并非一成不变。如果你有充分理由不同意某条一般规则，我们希望你能[提出修改](https://github.com/cli-guidelines/cli-guidelines)。

有一些基本规则你需要遵循。如果这些做错了，你的程序要么非常难以使用，要么完全损坏。

**尽可能使用命令行参数解析库。** 使用你的语言内置的，或一个好的第三方库。它们通常会以合理的方式处理参数、标志解析、帮助文本，甚至拼写建议。

以下是一些我们喜欢的：

**成功时返回零退出码，失败时返回非零。** 退出码是脚本判断程序成功还是失败的方式，所以你应该正确报告这一点。将非零退出码映射到最重要的失败模式。

**将输出发送到 `stdout`。** 命令的主要输出应该发送到 。任何机器可读的内容也应该发送到 ——这是管道默认发送内容的地方。`stdout` `stdout`

**将消息发送到 `stderr`。** 日志消息、错误等都应该发送到 。这意味着当命令被管道连接在一起时，这些消息会显示给用户，而不是被输入到下一个命令。`stderr`

**被请求时显示详尽的帮助文本。** 当传入 或 标志时显示帮助。这也适用于可能有自己帮助文本的子命令。`-h` `--help`

**默认显示简洁的帮助文本。** 当 或 需要参数才能运行，但运行时没有参数，显示简洁的帮助文本。`myapp` `myapp subcommand`

如果你的程序默认是交互式的（例如 ），你可以忽略这条指南。`npm init`

简洁的帮助文本应该只包括：

* 程序做什么的描述。
* 一两个调用示例。
* 标志的描述，除非标志很多。
* 传递 标志以获取更多信息的说明。`--help`

`jq` 做得很好。当你输入 时，它显示介绍性描述和示例，然后提示你传递 以获取完整的标志列表：`jq` `jq --help`

```
$ jq
jq - commandline JSON processor [version 1.6]

Usage:    jq [options] <jq filter> [file...]
    jq [options] --args <jq filter> [strings...]
    jq [options] --jsonargs <jq filter> [JSON_TEXTS...]

jq is a tool for processing JSON inputs, applying the given filter to
its JSON text inputs and producing the filter's results as JSON on
standard output.

The simplest filter is ., which copies jq's input to its output
unmodified (except for formatting, but note that IEEE754 is used
for number representation internally, with all that that implies).

For more advanced filters see the jq(1) manpage ("man jq")
and/or https://stedolan.github.io/jq

Example:

    $ echo '{"foo": 0}' | jq .
    {
        "foo": 0
    }

For a listing of options, use jq --help.

```

**当传入 `-h` 和 `--help` 时显示完整帮助。** 以下所有都应该显示帮助：

```
$ myapp
$ myapp --help
$ myapp -h

```

忽略传入的任何其他标志和参数——你应该能够在任何命令末尾添加 ，它就会显示帮助。不要重载 。`-h` `-h`

如果你的程序是类似 的，以下也应该提供帮助：`git`

```
$ myapp help
$ myapp help subcommand
$ myapp subcommand --help
$ myapp subcommand -h

```

**为反馈和问题提供支持路径。** 在顶级帮助文本中放一个网站或 GitHub 链接是常见做法。

**在帮助文本中链接到文档的网页版本。** 如果你对某个子命令有特定的页面或锚点，直接链接到那里。这在网页上有更详细的文档，或者有可能解释某些行为的延伸阅读时特别有用。

**以示例开头。** 用户倾向于使用示例而不是其他形式的文档，所以在帮助页面中首先展示它们，特别是常见的复杂用法。如果它有助于解释正在做什么并且不太长，也展示实际输出。

你可以用一系列示例讲述一个故事，逐步构建到复杂的用法。

\*\*如果你有大量示例，把它们放在别处，\*\*比如一个速查表命令或网页。有详尽的、高级的示例是有用的，但你不想让帮助文本太长。

对于更复杂的用例，例如与另一个工具集成，编写一个完整的教程可能是合适的。

**在帮助文本开头显示最常用的标志和命令。** 有很多标志是可以的，但如果你有一些真正常用的，首先显示它们。例如，Git 命令首先显示入门命令和最常用的子命令：

```
$ git
usage: git [--version] [--help] [-C <path>] [-c <name>=<value>]
           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]
           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
           <command> [<args>]

These are common Git commands used in various situations:

start a working area (see also: git help tutorial)
   clone      Clone a repository into a new directory
   init       Create an empty Git repository or reinitialize an existing one

work on the current change (see also: git help everyday)
   add        Add file contents to the index
   mv         Move or rename a file, a directory, or a symlink
   reset      Reset current HEAD to the specified state
   rm         Remove files from the working tree and from the index

examine the history and state (see also: git help revisions)
   bisect     Use binary search to find the commit that introduced a bug
   grep       Print lines matching a pattern
   log        Show commit logs
   show       Show various types of objects
   status     Show the working tree status
…

```

**在帮助文本中使用格式化。** 粗体标题使扫描变得更容易。但是，尽量以终端无关的方式做到这一点，这样你的用户就不会盯着一堵转义字符的墙。

`
**$ heroku apps --help**
list your apps

**USAGE**
  $ heroku apps

**OPTIONS**
  -A, --all          include apps in all teams
  -p, --personal     list apps in personal account when a default team is set
  -s, --space=space  filter by space
  -t, --team=team    team to use
  --json             output in json format

**EXAMPLES**
  $ heroku apps
  === My Apps
  example
  example2

  === Collaborated Apps
  theirapp   other@owner.name

**COMMANDS**
  apps:create     creates a new app
  apps:destroy    permanently destroy an app
  apps:errors     view app errors
  apps:favorites  list favorited apps
  apps:info       show detailed app information
  apps:join       add yourself to a team app
  apps:leave      remove yourself from a team app
  apps:lock       prevent team members from joining an app
  apps:open       open the app in a web browser
  apps:rename     rename an app
  apps:stacks     show the list of available stacks
  apps:transfer   transfer applications to another user or team
  apps:unlock     unlock an app so any team member can join
`

注意：当 通过分页器管道传输时，命令不输出转义字符。`heroku apps --help`

**如果用户做错了什么，并且你可以猜到他们的意思，就建议它。** 例如， 会告诉你应该运行 。`brew update jq` `brew upgrade jq`

你可以询问他们是否想运行建议的命令，但不要强迫他们。例如：

```
$ heroku pss
 ›   Warning: pss is not a heroku command.
Did you mean ps? [y/n]:

```

与其建议正确的语法，你可能会想直接为他们运行，就好像他们一开始就输入正确一样。有时这是正确的做法，但不总是。

首先，无效输入不一定意味着简单的打字错误——它通常可能意味着用户犯了逻辑错误，或误用了 shell 变量。假设他们的意思可能是危险的，特别是如果结果操作会修改状态。

其次，要意识到如果你改变了用户输入的内容，他们就不会学到正确的语法。实际上，你是在裁定他们输入的方式是有效和正确的，你在承诺无限期地支持它。在做出这个决定时要有意图，并记录两种语法。

**如果你的命令期望有东西管道输入，而 `stdin` 是交互式终端，立即显示帮助并退出。** 这意味着它不会像 那样只是挂起。或者，你可以向 打印一条日志消息。`cat` `stderr`

[帮助文本](https://clig.onev.dev/#help)的目的是给出你的工具是什么、有哪些选项可用以及如何执行最常见任务的简短、即时的概念。另一方面，文档是你详细说明的地方。这是人们去了解你的工具是做什么的、_不是_做什么的、它是如何工作的，以及如何做他们可能需要做的一切的地方。

**提供基于网页的文档。** 人们需要能够在线搜索你的工具的文档，并能够将其他人链接到特定部分。网页是最具包容性的文档格式。

**提供基于终端的文档。** 终端中的文档有几个很好的特性：访问速度快，与工具的特定安装版本保持同步，并且在没有互联网连接的情况下也能工作。

**考虑提供 man 页面。** [man 页面](https://en.wikipedia.org/wiki/Man%5Fpage)，Unix 的原始文档系统，今天仍在使用，许多用户在试图了解你的工具时会本能地首先检查 。为了更容易生成它们，你可以使用像 [ronn](http://rtomayko.github.io/ronn/ronn.1.html) 这样的工具（它也可以生成你的网页文档）。`man mycmd`

然而，不是每个人都知道 ，而且它不能在所有平台上运行，所以你还应该确保你的终端文档可以通过工具本身访问。例如， 和 通过 子命令使其 man 页面可访问，所以 等同于 。`man` `git` `npm` `help` `npm help ls` `man npm-ls`

```
NPM-LS(1)                                                            NPM-LS(1)

NAME
       npm-ls - List installed packages

SYNOPSIS
         npm ls [[<@scope>/]<pkg> ...]

         aliases: list, la, ll

DESCRIPTION
       This command will print to stdout all the versions of packages that are
       installed, as well as their dependencies, in a tree-structure.

       ...

```

**人类可读的输出是最重要的。** 人类优先，机器其次。判断特定输出流（ 或 ）是否被人类阅读的最简单、最直接的启发式方法是_它是否是 TTY_。无论你使用什么语言，它都会有一个用于此目的的实用程序或库（例如 [Python](https://stackoverflow.com/questions/858623/how-to-recognize-whether-a-script-is-running-on-a-tty)、[Node](https://nodejs.org/api/process.html#process%2Aa%2Anote%2Aon%2Aprocess%2Ai%2Ao)、[Go](https://github.com/mattn/go-isatty)）。`stdout` `stderr`

_关于[什么是 TTY](https://unix.stackexchange.com/a/4132) 的延伸阅读。_

**在不影响可用性的情况下提供机器可读的输出。** 文本流是 UNIX 中的通用接口。程序通常输出文本行，程序通常期望文本行作为输入，因此你可以将多个程序组合在一起。这通常是为了使编写脚本成为可能，但它也可以帮助人类使用程序的可用性。例如，用户应该能够将输出管道到 ，它应该按照他们期望的方式工作。`grep`

**如果人类可读的输出破坏了机器可读的输出，使用 `--plain` 以纯表格文本格式显示输出，以便与 `grep` 或 `awk` 等工具集成。** 在某些情况下，你可能需要以不同的方式输出信息以使其对人类可读。

例如，如果你正在显示一个基于行的表格，你可能会选择将一个单元格拆分成多行，在保持在屏幕宽度内的同时容纳更多信息。这打破了每行一条数据的预期行为，所以你应该为脚本提供一个 标志，它禁用所有此类操作并每行输出一条记录。`--plain`

**如果传入了 `--json`，将输出显示为格式化的 JSON。** JSON 允许比纯文本更多的结构，所以它使输出和处理复杂数据结构变得更加容易。[jq](https://stedolan.github.io/jq/) 是在命令行上处理 JSON 的常用工具，现在有一个[完整的工具生态系统](https://ilya-sher.org/2018/04/10/list-of-json-tools-for-command-line/)输出和操作 JSON。

它也在网页上广泛使用，所以通过使用 JSON 作为程序的输入和输出，你可以使用 直接管道到和从 Web 服务。`curl`

**成功时显示输出，但保持简短。** 传统上，当一切正常时，UNIX 命令不向用户显示任何输出。这在它们被脚本使用时是有意义的，但在被人类使用时可能会使命令看起来像是挂起或损坏了。例如， 不会打印任何东西，即使它需要很长时间。`cp`

什么都不打印很少是最佳的默认行为，但通常最好是少打印一些。

对于你确实希望没有输出的情况（例如，在 shell 脚本中使用时），为了避免笨拙地将 重定向到 ，你可以提供一个 选项来抑制所有非必要的输出。`stderr` `/dev/null` `-q`

**如果你改变了状态，告诉用户。** 当命令改变系统的状态时，解释刚刚发生了什么特别有价值，这样用户可以在脑海中建立系统的状态模型——特别是当结果与用户请求的不直接对应时。

例如， 准确地告诉你它在做什么，以及远程分支的新状态：`git push`

```
$ git push
Enumerating objects: 18, done.
Counting objects: 100% (18/18), done.
Delta compression using up to 8 threads
Compressing objects: 100% (10/10), done.
Writing objects: 100% (10/10), 2.09 KiB | 2.09 MiB/s, done.
Total 10 (delta 8), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (8/8), completed with 8 local objects.
To github.com:replicate/replicate.git
 + 6c22c90...a2a5217 bfirsh/fix-delete -> bfirsh/fix-delete

```

**使查看系统当前状态变得容易。** 如果你的程序进行大量复杂的状态变化，并且这些变化在文件系统中不是立即可见的，确保你使这容易查看。

例如， 尽可能多地告诉你关于 Git 仓库当前状态的信息，以及一些如何修改状态的提示：`git status`

```
$ git status
On branch bfirsh/fix-delete
Your branch is up to date with 'origin/bfirsh/fix-delete'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   cli/pkg/cli/rm.go

no changes added to commit (use "git add" and/or "git commit -a")

```

**建议用户应该运行的命令。** 当多个命令形成一个工作流时，向用户建议他们接下来可以运行的命令可以帮助他们学习如何使用你的程序并发现新功能。例如，在上面的 输出中，它建议了你可以运行来修改你正在查看的状态的命令。`git status`

**跨越程序内部世界边界的操作通常应该是显式的。** 这包括：

* 读取或写入用户没有显式传递为参数的文件（除非这些文件存储内部程序状态，如缓存）。
* 与远程服务器通信，例如下载文件。

**增加信息密度——用 ASCII 艺术！** 例如， 以可扫描的方式显示权限。当你第一次看到它时，你可以忽略大部分信息。然后，随着你学习它的工作原理，你会随着时间的推移捕捉到更多的模式。`ls`

```
-rw-r--r-- 1 root root     68 Aug 22 23:20 resolv.conf
lrwxrwxrwx 1 root root     13 Mar 14 20:24 rmt -> /usr/sbin/rmt
drwxr-xr-x 4 root root   4.0K Jul 20 14:51 security
drwxr-xr-x 2 root root   4.0K Jul 20 14:53 selinux
-rw-r----- 1 root shadow  501 Jul 20 14:44 shadow
-rw-r--r-- 1 root root    116 Jul 20 14:43 shells
drwxr-xr-x 2 root root   4.0K Jul 20 14:57 skel
-rw-r--r-- 1 root root      0 Jul 20 14:43 subgid
-rw-r--r-- 1 root root      0 Jul 20 14:43 subuid

```

**有目的地使用颜色。** 例如，你可能想要高亮一些文本以便用户注意到它，或使用红色表示错误。不要过度使用——如果所有东西都是不同的颜色，那么颜色就没有意义，只会使阅读变得更困难。

**如果你的程序不在终端中或用户请求，禁用颜色。** 这些情况应该禁用颜色：

* `stdout` 或 不是交互式终端（TTY）。最好单独检查——如果你将 管道到另一个程序，在 上获得颜色仍然是有用的。`stderr` `stdout` `stderr`
* `NO_COLOR` 环境变量被设置且不为空（无论其值是什么）。
* `TERM` 环境变量的值为 。`dumb`
* 用户传入了 选项。`--no-color`
* 如果用户想要专门为你的程序禁用颜色，你可能还想添加一个 环境变量。`MYAPP*NO*COLOR`

**如果 `stdout` 不是交互式终端，不显示任何动画。** 这将阻止进度条在 CI 日志输出中变成圣诞树。

**在能让事情更清晰的地方使用符号和 emoji。** 如果你需要区分几件事、吸引用户的注意力或只是增加一点个性，图片可能比文字更好。但要小心——很容易过度使用，使你的程序看起来杂乱或感觉像玩具。

例如，[yubikey-agent](https://github.com/FiloSottile/yubikey-agent) 使用 emoji 为输出添加结构，这样它就不只是一堵文字墙，并用 ❌ 来吸引你对重要信息的注意：

```
$ yubikey-agent -setup
🔐 The PIN is up to 8 numbers, letters, or symbols. Not just numbers!
❌ The key will be lost if the PIN and PUK are locked after 3 incorrect tries.

Choose a new PIN/PUK:
Repeat the PIN/PUK:

🧪 Retriculating splines …

✅ Done! This YubiKey is secured and ready to go.
🤏 When the YubiKey blinks, touch it to authorize the login.

🔑 Here's your new shiny SSH public key:
ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBCEJ/
UwlHnUFXgENO3ifPZd8zoSKMxESxxot4tMgvfXjmRp5G3BGrAnonncE7Aj11pn3SSYgEcrrn2sMyLGpVS0=

💭 Remember: everything breaks, have a backup plan for when this YubiKey does.

```

**默认情况下，不要输出只有软件创建者才能理解的信息。** 如果一段输出只是帮助你（开发者）理解你的软件在做什么，它几乎肯定不应该默认显示给普通用户——只在详细模式下显示。

邀请外部人士和项目新手提供可用性反馈。他们会帮助你看到你离代码太近而注意不到的重要问题。

**不要把 `stderr` 当作日志文件，至少不要默认这样做。** 不要打印日志级别标签（、 等）或无关的上下文信息，除非在详细模式下。`ERR` `WARN`

**如果你要输出大量文本，使用分页器（如 `less`）。** 例如， 默认就是这样做的。使用分页器可能容易出错，所以要小心实现，这样你就不会让用户体验变得更糟。只有当 或 是交互式终端时才使用分页器。`git diff` `stdin` `stdout`

`less` 的一组好的合理选项是 。如果内容填满一个屏幕，这不会分页，搜索时忽略大小写，启用颜色和格式化，并在 退出时将内容留在屏幕上。`less -FIRX` `less`

你的语言中可能有比管道到 更健壮的库。例如，Python 中的 [pypager](https://github.com/prompt-toolkit/pypager)。`less`

查阅文档的最常见原因之一是修复错误。如果你能把错误变成文档，那将为用户节省大量时间。

**捕获错误并为人类重写它们。** 如果你预期会发生错误，捕获它并重写错误消息使其有用。把它想象成一场对话，用户做错了什么，程序正在引导他们走向正确的方向。例如：“无法写入 file.txt。你可能需要运行 ‘chmod +w file.txt’ 使其可写。”

**信噪比至关重要。** 你产生的无关输出越多，用户就需要越长时间来弄清楚他们做错了什么。如果你的程序产生多个相同类型的错误，考虑将它们分组在一个解释性标题下，而不是打印许多看起来相似的行。

**考虑用户会首先看哪里。** 把最重要的信息放在输出的末尾。眼睛会被红色文本吸引，所以要有意图地、谨慎地使用它。

**如果有意外或无法解释的错误，提供调试和回溯信息，以及如何提交 bug 的说明。** 话虽如此，不要忘记信噪比：你不想用他们不理解的信息压倒用户。考虑将调试日志写入文件而不是打印到终端。

**使提交 bug 报告变得轻而易举。** 你可以做的一件好事是提供一个 URL，并让它预填尽可能多的信息。

术语说明：

* _参数_，或 _args_，是命令的位置参数。例如，你提供给 的文件路径就是 args。参数的顺序通常很重要： 和 意思不同。`cp` `cp foo bar` `cp bar foo`
* _标志_是命名参数，用连字符和单字母名称（）或双连字符和多字母名称（）表示。它们可能包含也可能不包含用户指定的值（ 或 ）。标志的顺序，一般来说，不影响程序语义。`-r` `--recursive` `--file foo.txt` `--file=foo.txt`

**优先使用标志而非参数。** 这需要多打一点字，但让发生的事情更清楚。它还使将来更容易修改你接受输入的方式。有时使用参数时，不破坏现有行为或造成歧义就无法添加新输入。

**所有标志都要有完整长度的版本。** 例如，同时有 和 。在脚本中有完整版本是有用的，你想要详细和描述性，而且你不必到处查找标志的含义。`-h` `--help`

\*\*只对常用标志使用单字母标志，\*\*特别是在使用子命令时的顶级。这样你就不会"污染"你的短标志命名空间，迫使你在将来添加标志时使用复杂的字母和大小写。

**对多个文件的简单操作，多个参数是可以的。** 例如，。这也使它与通配符一起工作：。`rm file1.txt file2.txt file3.txt` `rm *.txt`

**如果你有两个或更多不同事物的参数，你可能做错了什么。** 例外是常见的主要操作，其中简洁性值得记忆。例如，。`cp <source> <destination>`

**如果有标准，使用标准的标志名称。** 如果另一个常用命令使用某个标志名称，最好遵循那个现有模式。这样，用户不必记住两个不同的选项（以及它适用于哪个命令），用户甚至可以在不查看帮助文本的情况下猜测选项。

以下是常用选项的列表：

* `-a`、：全部。例如，、。`--all` `ps` `fetchmail`
* `-d`、：显示调试输出。`--debug`
* `-f`、：强制。例如， 将强制删除文件，即使它认为没有权限这样做。这对于执行通常需要用户确认的破坏性操作的命令也很有用，但你想在脚本中强制执行那个破坏性操作。`--force` `rm -f`
* `-h`、：帮助。这应该只意味着帮助。参见[帮助](https://clig.onev.dev/#help)部分。`--help`
* `-n`、：预演。不运行命令，但描述如果运行命令会发生的更改。例如，、。`--dry-run` `rsync` `git add`
* `-o`、：输出文件。例如，、。`--output` `sort` `gcc`
* `-p`、：端口。例如，、。`--port` `psql` `ssh`
* `-q`、：安静。显示更少的输出。这在为人类显示输出时特别有用，你可能想在脚本中运行时隐藏它。`--quiet`
* `-u`、：用户。例如，、。`--user` `ps` `ssh`
* `--version`：版本。
* `-v`：这通常可以表示 verbose 或 version。你可能想用 表示 verbose，用这个表示 version，或者为了避免混淆什么都不用。`-d`

**使默认值对大多数用户来说是正确的。** 使事物可配置是好的，但大多数用户不会找到正确的标志并记得一直使用它（或为它创建别名）。如果它不是默认值，你就是在为大多数用户使体验变得更糟。

例如， 有简洁的默认输出以优化脚本和其他历史原因，但如果今天设计它，它可能会默认为 。`ls` `ls -lhF`

**提示用户输入。** 如果用户没有传递参数或标志，提示它。（另见：[交互性](https://clig.onev.dev/#interactivity)）

**永远不要_要求_提示。** 总是提供一种通过标志或参数传递输入的方式。如果 不是交互式终端，跳过提示，只要求那些标志/参数。`stdin`

**在做任何危险的事情之前确认。** 一个常见的惯例是，如果是交互式运行，提示用户输入 或 ，否则要求他们传递 或 。`y` `yes` `-f` `--force`

“危险"是一个主观术语，有不同级别的危险：

* \*\*轻度：\*\*小的、局部的更改，如删除一个文件。你可能想要提示确认，也可能不想。例如，如果用户明确运行一个名为"delete"之类的命令，你可能不需要询问。
* \*\*中度：\*\*更大的局部更改，如删除一个目录，删除某种远程资源的远程更改，或无法轻易撤销的复杂批量修改。你通常想在这里提示确认。考虑给用户一种方式来"预演"操作，这样他们可以在提交之前看到会发生什么。
* \*\*严重：\*\*删除复杂的东西，如整个远程应用程序或服务器。你不只是想在这里提示确认——你想使意外确认变得困难。考虑要求他们输入一些非平凡的东西，如他们要删除的东西的名称。让他们可以选择传递一个标志如 ，这样它仍然可以脚本化。`--confirm="name-of-thing"`

考虑是否有非明显的方式意外销毁东西。例如，想象一种情况，将配置文件中的一个数字从 10 改为 1 意味着 9 个东西将被隐式删除——这应该被认为是严重风险，应该难以意外做到。

**如果输入或输出是文件，支持 `-` 从 `stdin` 读取或写入 `stdout`。** 这让另一个命令的输出成为你的命令的输入，反之亦然，而不使用临时文件。例如， 可以从 提取文件：`tar` `stdin`

```
$ curl https://example.com/something.tar.gz | tar xvf -

```

**如果标志可以接受可选值，允许一个特殊词如"none”。** 例如， 接受一个可选的替代 文件的文件名，而 运行 SSH 不使用配置文件。不要只使用空白值——这会使参数是标志值还是参数变得模糊。`ssh -F` `ssh_config` `ssh -F none`

**如果可能，使参数、标志和子命令的顺序无关。** 很多 CLI，特别是那些有子命令的，对你可以在哪里放置各种参数有不成文的规则。例如，一个命令可能有一个 标志，只有当你把它放在子命令之前才起作用：`--foo`

```
mycmd --foo=1 subcmd
works

$ mycmd subcmd --foo=1
unknown flag: --foo

```

这对用户来说可能非常困惑——特别是考虑到用户在试图让命令工作时最常见的事情之一是按向上箭头获取上次调用，在末尾加上另一个选项，然后再次运行。如果可能，尝试使两种形式等效，尽管你可能会遇到参数解析器的限制。

**不要直接从标志读取密钥。** 当命令接受密钥时，例如通过 标志，标志值会将密钥泄露到 输出中，可能还有 shell 历史。而且，这种标志鼓励使用不安全的环境变量存储密钥。（环境变量是不安全的，因为它们通常可以被其他用户读取，它们的值最终会进入调试日志等。）`--password` `ps`

考虑只通过文件接受敏感数据，例如通过 标志，或通过 。 标志允许在各种上下文中谨慎地传递密钥。`--password-file` `stdin` `--password-file`

（在 Bash 中可以通过使用 将文件内容传递给标志。这种方法有上面提到的同样的安全问题。最好避免。）`--password $(< password.txt)`

**只有当 `stdin` 是交互式终端（TTY）时才使用提示或交互元素。** 这是一种相当可靠的方式来判断你是在将数据管道到命令还是在脚本中运行，在这种情况下提示不会工作，你应该抛出一个错误，告诉用户要传递什么标志。

**如果传入了 `--no-input`，不要提示或做任何交互式的事情。** 这允许用户有一个明确的方式来禁用命令中的所有提示。如果命令需要输入，失败并告诉用户如何将信息作为标志传递。

**如果你在提示密码，不要在用户输入时打印它。** 这是通过在终端中关闭回显来完成的。你的语言应该有这方面的辅助函数。

**让用户可以退出。** 明确如何退出。（不要做 vim 做的那样。）如果你的程序在网络 I/O 等上挂起，总是让 Ctrl-C 仍然工作。如果它是程序执行的包装器，而 Ctrl-C 不能退出（SSH、tmux、telnet 等），明确如何做到这一点。例如，SSH 允许使用 转义字符进行转义序列。`~`

如果你有一个足够复杂的工具，你可以通过制作一组子命令来降低其复杂性。如果你有几个非常密切相关的工具，你可以通过将它们组合成一个命令使它们更容易使用和发现（例如，RCS vs. Git）。

它们对共享东西很有用——全局标志、帮助文本、配置、存储机制。

**在子命令之间保持一致。** 对相同的东西使用相同的标志名称，有类似的输出格式等。

**对多级子命令使用一致的名称。** 如果一个复杂的软件有很多对象和可以对这些对象执行的操作，使用两级子命令是一种常见模式，其中一个是名词，一个是动词。例如，。在不同类型的对象之间使用一致的动词。`docker container create`

`noun verb` 或 顺序都可以工作，但 似乎更常见。`verb noun` `noun verb`

**不要有模糊或名称相似的命令。** 例如，有两个名为"update"和"upgrade"的子命令是相当令人困惑的。你可能想使用不同的词，或用额外的词来消除歧义。

**验证用户输入。** 在你的程序接受用户数据的每个地方，它最终都会收到错误的数据。尽早检查并在任何坏事发生之前退出，并[使错误可理解](https://clig.onev.dev/#errors)。

**响应比快更重要。** 在 100 毫秒内向用户打印一些东西。如果你正在进行网络请求，在你做之前打印一些东西，这样它就不会挂起并看起来像坏了。

**如果某事需要很长时间，显示进度。** 如果你的程序有一段时间不显示输出，它会看起来像坏了。一个好的转圈或进度指示器可以使程序看起来比实际更快。

Ubuntu 20.04 有一个很好的进度条，固定在终端底部。

如果进度条长时间停在一个地方，用户不会知道事情是否仍在发生或程序是否崩溃了。显示估计剩余时间，或者甚至只是有一个动画组件，来向他们保证你仍在工作，这是好的。

有许多好的库用于生成进度条。例如，Python 的 [tqdm](https://github.com/tqdm/tqdm)，Go 的 [schollz/progressbar](https://github.com/schollz/progressbar)，和 Node.js 的 [node-progress](https://github.com/visionmedia/node-progress)。

**在可能的地方并行做事，但要深思熟虑。** 在 shell 中报告进度已经很困难了；为并行进程做这件事难十倍。确保它是健壮的，输出不会令人困惑地交错。如果你可以使用库，就使用——这是你不想自己写的代码。像 Python 的 [tqdm](https://github.com/tqdm/tqdm) 和 Go 的 [schollz/progressbar](https://github.com/schollz/progressbar) 这样的库原生支持多个进度条。

好处是它可能是一个巨大的可用性提升。例如， 的多个进度条提供了对正在发生什么的关键洞察。`docker pull`

```
$ docker image pull ruby
Using default tag: latest
latest: Pulling from library/ruby
6c33745f49b4: Pull complete
ef072fc32a84: Extracting [================================================>  ]  7.569MB/7.812MB
c0afb8e68e0b: Download complete
d599c07d28e6: Download complete
f2ecc74db11a: Downloading [=======================>                           ]  89.11MB/192.3MB
3568445c8bf2: Download complete
b0efebc74f25: Downloading [===========================================>       ]  19.88MB/22.88MB
9cb1ba6838a0: Download complete

```

要注意的一件事是：当事情进展_顺利_时，在进度条后面隐藏日志使用户更容易理解正在发生什么，但如果有错误，确保你打印出日志。否则，将很难调试。

**让事情超时。** 允许网络超时被配置，并有一个合理的默认值，这样它就不会永远挂起。

**使其可恢复。** 如果程序因为某些暂时性原因失败（例如，互联网连接断开），你应该能够按 和 ，它应该从它离开的地方继续。`<up>` `<enter>`

**使其仅崩溃。** 这是幂等性的下一步。如果你可以避免在操作后需要做任何清理，或者你可以将该清理推迟到下次运行，你的程序可以在失败或中断时立即退出。这使它既更健壮又更响应。

**人们会误用你的程序。** 为此做好准备。他们会把它包装在脚本中，在糟糕的互联网连接上使用它，同时运行它的多个实例，并在你没有测试过的环境中使用它，有你没有预料到的怪癖。（你知道 macOS 文件系统是大小写不敏感但同时保留大小写的吗？）

在任何类型的软件中，接口不经过长期和有充分文档记录的弃用过程就不能改变是至关重要的。子命令、参数、标志、配置文件、环境变量：这些都是接口，你承诺保持它们工作。（[语义化版本控制](https://semver.org/)只能原谅这么多变化；如果你每个月都推出一个主版本号升级，那就没有意义了。）

**尽可能保持变更是增量式的。** 与其以向后不兼容的方式修改标志的行为，也许你可以添加一个新标志——只要它不会使接口太臃肿。（另见：[优先使用标志而非参数](https://clig.onev.dev/#arguments-and-flags)。）

**在做非增量式变更之前发出警告。** 最终，你会发现你无法避免破坏一个接口。在你这样做之前，在程序本身中警告你的用户：当他们传递你要弃用的标志时，告诉他们它即将改变。确保他们有办法今天就修改他们的用法以使其面向未来，并告诉他们怎么做。

如果可能的话，你应该检测他们何时已经改变了他们的用法，不再显示警告：现在当你最终推出变更时他们不会注意到任何东西。

**改变人类的输出通常是可以的。** 使接口易于使用的唯一方法是迭代它，如果输出被认为是接口，那么你就不能迭代它。鼓励你的用户在脚本中使用 或 来保持输出稳定（见[输出](https://clig.onev.dev/#output)）。`--plain` `--json`

**不要有万能子命令。** 如果你有一个可能是最常用的子命令，你可能会想让人们为了简洁而完全省略它。例如，假设你有一个包装任意 shell 命令的 命令：`run`

```
$ mycmd run echo "hello world"

```

你可以做到这样，如果 的第一个参数不是现有子命令的名称，你就假设用户是指 ，这样他们就可以只输入这个：`mycmd` `run`

```
$ mycmd echo "hello world"

```

然而，这有一个严重的缺点：现在你永远不能添加一个名为 的子命令——或_任何东西_——而不冒险破坏现有用法。如果有一个脚本使用 ，在那个用户升级到你工具的新版本后，它会做完全不同的事情。`echo` `mycmd echo`

**不允许子命令的任意缩写。** 例如，假设你的命令有一个 子命令。当你添加它时，你想为用户节省一些打字，所以你允许他们输入任何非歧义的前缀，如 ，甚至只是 ，并让它成为 的别名。现在你被困住了：你不能再添加任何以 开头的命令，因为有脚本假设 意味着 。`install` `mycmd ins` `mycmd i` `mycmd install` `i` `i` `install`

别名没有什么问题——节省打字是好的——但它们应该是显式的并保持稳定。

**不要创建"定时炸弹"。** 想象 20 年后。你的命令还会像今天一样运行吗，还是因为互联网上某些外部依赖项已经改变或不再维护而停止工作？最有可能在 20 年后不存在的服务器是你现在正在维护的那个。（但也不要内置一个阻塞调用到 Google Analytics。）

**如果用户按下 Ctrl-C（INT 信号），尽快退出。** 在你开始清理之前立即说些什么。为任何清理代码添加超时，这样它就不能永远挂起。

**如果用户在可能需要很长时间的清理操作期间按下 Ctrl-C，跳过它们。** 告诉用户当他们再次按下 Ctrl-C 时会发生什么，以防它是破坏性操作。

例如，当退出 Docker Compose 时，你可以第二次按 Ctrl-C 来强制你的容器立即停止，而不是优雅地关闭它们。

```
$  docker-compose up
…
^CGracefully stopping... (press Ctrl+C again to force)

```

你的程序应该预期在没有运行清理的情况下启动。（见 [Crash-only software: More than meets the eye](https://lwn.net/Articles/191059/)。）

命令行工具有很多不同类型的配置，以及很多不同的提供方式（标志、环境变量、项目级配置文件）。提供每条配置的最佳方式取决于几个因素，其中最重要的是_特定性_、_稳定性_和_复杂性_。

配置一般分为几类：

1. 可能在命令的每次调用之间变化。  
示例：  
   * 设置调试输出的级别  
   * 启用程序的安全模式或预演  
建议：**使用[标志](https://clig.onev.dev/#arguments-and-flags)。** [环境变量](https://clig.onev.dev/#environment-variables)也可能有用。
2. 通常在每次调用之间稳定，但不总是。可能在项目之间变化。在同一项目的不同用户之间肯定会变化。  
这种类型的配置通常特定于单个计算机。  
示例：  
   * 为程序启动所需的项目提供非默认路径  
   * 指定颜色应该如何或是否出现在输出中  
   * 指定一个 HTTP 代理服务器来路由所有请求  
建议：**使用[标志](https://clig.onev.dev/#arguments-and-flags)，可能也使用[环境变量](https://clig.onev.dev/#environment-variables)。** 用户可能想在他们的 shell 配置文件中设置变量以使其全局应用，或在 中为特定项目设置。`.env`  
如果这种配置足够复杂，它可能需要一个自己的配置文件，但环境变量通常就足够了。
3. 在项目内稳定，对所有用户。  
这是属于版本控制的配置类型。像 、 和 这样的文件都是这方面的例子。`Makefile` `package.json` `docker-compose.yml`  
建议：**使用命令特定的、版本控制的文件。**

**遵循 XDG 规范。** 2010 年，X Desktop Group，现在的 [freedesktop.org](https://freedesktop.org)，制定了一个关于配置文件可能位于的基本目录位置的规范。一个目标是通过支持一个通用的 文件夹来限制用户主目录中点文件的增殖。XDG 基本目录规范（[完整规范](https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html)，[摘要](https://wiki.archlinux.org/index.php/XDG%5FBase%5FDirectory#Specification)）被 yarn、fish、wireshark、emacs、neovim、tmux 和许多你知道和喜欢的其他项目支持。`~/.config`

**如果你自动修改不是你程序的配置，征求用户同意并告诉他们你在做什么。** 优先创建一个新的配置文件（例如 ）而不是追加到现有的配置文件（例如 ）。如果你必须追加或修改系统范围的配置文件，在该文件中使用带日期的注释来划分你的添加。`/etc/cron.d/myapp` `/etc/crontab`

**按优先顺序应用配置参数。** 以下是配置参数的优先级，从高到低：

* 标志
* 正在运行的 shell 的环境变量
* 项目级配置（例如 ）`.env`
* 用户级配置
* 系统范围配置

**环境变量用于_随命令运行上下文而变化_的行为。** 环境变量的"环境"是终端会话——命令运行的上下文。所以，环境变量可能在每次命令运行时变化，或在一台机器上的终端会话之间变化，或在跨多台机器的一个项目的实例之间变化。

环境变量可能复制标志或配置参数的功能，或者它们可能与这些不同。参见[配置](https://clig.onev.dev/#configuration)以获取常见配置类型的分解和环境变量最合适的时机的建议。

**为了最大的可移植性，环境变量名称必须只包含大写字母、数字和下划线（并且不能以数字开头）。** 这意味着 和 是唯一同时也是有效环境变量名称的表情符号。`O_O` `OWO`

**目标是单行环境变量值。** 虽然多行值是可能的，但它们会造成 命令的可用性问题。`env`

**避免占用广泛使用的名称。** 这里有一个 [POSIX 标准环境变量列表](https://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd%5Fchap08.html)。

**尽可能检查通用环境变量的配置值：**

* `NO_COLOR`，禁用颜色（见[输出](https://clig.onev.dev/#output)）或 启用它并忽略检测逻辑`FORCE_COLOR`
* `DEBUG`，启用更详细的输出
* `EDITOR`，如果你需要提示用户编辑文件或输入多于一行
* `HTTP_PROXY`、、 和 ，如果你要执行网络操作 （你使用的 HTTP 库可能已经检查这些了。）`HTTPS_PROXY` `ALL_PROXY` `NO_PROXY`
* `SHELL`，如果你需要打开用户首选 shell 的交互式会话 （如果你需要执行 shell 脚本，使用特定的解释器如 ）`/bin/sh`
* `TERM`、 和 ，如果你要使用终端特定的转义序列`TERMINFO` `TERMCAP`
* `TMPDIR`，如果你要创建临时文件
* `HOME`，用于定位配置文件
* `PAGER`，如果你想自动分页输出
* `LINES` 和 ，用于依赖于屏幕大小的输出（例如，表格）`COLUMNS`

**在适当的地方从 `.env` 读取环境变量。** 如果命令定义的环境变量在用户在特定目录中工作时不太可能改变，那么它也应该从本地 文件读取它们，这样用户可以为不同的项目配置不同的设置，而不必每次都指定它们。许多语言都有用于读取 文件的库（[Rust](https://crates.io/crates/dotenv)、[Node](https://www.npmjs.com/package/dotenv)、[Ruby](https://github.com/bkeepers/dotenv)）。`.env` `.env`

**不要使用 `.env` 作为适当的[配置文件](https://clig.onev.dev/#configuration)的替代品。** 文件有很多限制：`.env`

* `.env` 文件通常不存储在源代码控制中
* （因此，存储在其中的任何配置都没有历史记录）
* 它只有一种数据类型：字符串
* 它容易被组织得很糟糕
* 它容易引入编码问题
* 它经常包含敏感的凭据和密钥材料，这些最好更安全地存储

如果看起来这些限制会妨碍可用性或安全性，那么专用的配置文件可能更合适。

**不要从环境变量读取密钥。** 虽然环境变量可能方便存储密钥，但它们已被证明太容易泄露：

* 导出的环境变量被发送到每个进程，从那里可以很容易地泄露到日志中或被窃取
* Shell 替换如 将泄露到全局可读的进程状态中。（cURL 提供了 替代方案，用于从文件读取敏感头。）`curl -H "Authorization: Bearer $BEARER_TOKEN"` `-H @filename`
* Docker 容器环境变量可以被任何有 Docker 守护进程访问权限的人通过 查看`docker inspect`
* systemd 单元中的环境变量可以通过 全局读取`systemctl show`

密钥只应该通过凭据文件、管道、 套接字、密钥管理服务或其他 IPC 机制接受。`AF_UNIX`

> “注意对缩写的痴迷和对大写字母的回避；\[Unix\] 是由对他们来说重复性压力障碍就像矿工的黑肺病一样的人发明的系统。长名字被磨损成三个字母的残块，就像被河流磨平的石头。” — Neal Stephenson，_[In the Beginning was the Command Line](https://web.stanford.edu/class/cs81n/command.txt)_

你的程序名称在 CLI 上特别重要：你的用户会一直输入它，它需要容易记住和输入。

**使它成为一个简单、容易记住的词。** 但不要太通用，否则你会踩到其他命令的脚趾头并让用户困惑。例如，ImageMagick 和 Windows 都使用了命令 。`convert`

**只使用小写字母，如果真的需要就用破折号。** 是一个好名字， 不是。`curl` `DownloadURL`

**保持简短。** 用户会一直输入它。不要把它做得_太_短：最短的命令最好保留给一直使用的常见实用程序，如 、、。`cd` `ls` `ps`

**使它容易输入。** 如果你期望人们整天输入你的命令名，让他们的手轻松一点。

一个真实的例子：在 Docker Compose 成为 之前很久，它是 [plum](https://github.com/aanand/fig/blob/0eb7d308615bae1ad4be1ca5112ac7b6b6cbfbaf/setup.py#L26)。这原来是一个如此尴尬的、单手跳跃的动作，以至于它立即被重命名为 [fig](https://github.com/aanand/fig/commit/0cafdc9c6c19dab2ef2795979dc8b2f48f623379)，它——除了更短之外——流畅得多。`docker compose`

**如果可能，作为单个二进制文件分发。** 如果你的语言默认不编译成二进制可执行文件，看看它是否有像 [PyInstaller](https://www.pyinstaller.org/) 这样的东西。如果你真的不能作为单个二进制文件分发，使用平台的原生包安装程序，这样你就不会在磁盘上散布无法轻易删除的东西。轻踏用户的计算机。

如果你正在制作语言特定的工具，如代码检查器，那么这条规则不适用——可以安全地假设用户的计算机上安装了该语言的解释器。

**使它容易卸载。** 如果需要说明，把它们放在安装说明的底部——人们想要卸载软件最常见的时机之一就是在安装之后。

使用指标可以帮助了解用户如何使用你的程序，如何使其更好，以及在哪里集中精力。但是，与网站不同，命令行用户期望控制自己的环境，当程序在后台做事而不告诉他们时会感到惊讶。

**未经同意不要发送使用或崩溃数据。** 用户会发现的，他们会很生气。非常明确地说明你收集了什么，为什么收集，它有多匿名，你如何匿名化它，以及你保留多长时间。

理想情况下，询问用户是否想要贡献数据（“选择加入”）。如果你选择默认这样做（“选择退出”），那么在你的网站上或首次运行时清楚地告诉用户，并使其容易禁用。

收集使用统计数据的项目示例：

* Angular.js 以功能优先级的名义[使用 Google Analytics 收集详细分析数据](https://angular.io/analytics)。你必须明确选择加入。如果你想在组织内跟踪 Angular 使用情况，你可以将跟踪 ID 更改为指向你自己的 Google Analytics 属性。
* Homebrew 将指标发送到 Google Analytics 并有[一个很好的 FAQ](https://docs.brew.sh/Analytics) 详细说明他们的做法。

**考虑收集分析数据的替代方案。**

* 检测你的网页文档。如果你想知道人们如何使用你的 CLI 工具，围绕你想要最好理解的用例制作一组文档，看看它们随时间的表现如何。看看人们在你的文档中搜索什么。
* 检测你的下载。这可以是一个粗略的指标来了解使用情况和用户运行的操作系统。
* 与你的用户交谈。联系并询问人们如何使用你的工具。在你的文档和仓库中鼓励反馈和功能请求，并尝试从提交反馈的人那里获取更多上下文。

hidden text to trigger resize events if fonts change

---

# [五条0119] 字节扣子2.0：AI技能商店，经验直接变现
发布日期：2026/01/19

### 

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/UicQ7HgWiaUb3GPr5ef2nr16IkZtBTTaib17hxSMNibfNLQDMiaibckHmwqomEX4kUiaicDc8GNodKDObtVnJuJLfTIHbA/640?wx_fmt=jpeg&from=appmsg&watermark=1#imgIndex=0)

### 

  
**新智元报道** 

编辑：KingHZ 犀牛

##### **【新智元导读】在全球AI共识下，Agent Skill成为新战场。在国内，字节扣子率先推出Coze Skill，让你的方法论、个人心得瞬间封装成可复用包；加上长期任务的「目标导向协作」，AI帮你拆解步骤、执行计划，真正实现「人类经验注入AI智能体」。**

最近，硅谷被澳洲放羊的大叔给掀翻了。

[在澳洲牧场上、平时与羊群为伍的大叔Geoffrey Huntley，仅仅用了5行代码，就捅破了Claude Code编程的天花板](https://mp.weixin.qq.com/s?%5F%5Fbiz=MzI3MTA0MTk1MA==&mid=2652664687&idx=1&sn=2dbb5ec827c5746577de94c5d12a80fa&scene=21#wechat%5Fredirect)。

另一边，Cursor的CEO让GPT-5.2连续跑了**[168小时](https://mp.weixin.qq.com/s?%5F%5Fbiz=MzI3MTA0MTk1MA==&mid=2652664792&idx=1&sn=ef481284b5d67f4d32d7f6ec2c5f3cea&scene=21#wechat%5Fredirect)**。它写了**3万行代码**，从零搭出一个新浏览器。

一夜之间，「智能体提高生产力」不再是一句干瘪的口号，而变成了**可复制的工作方法**。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/UicQ7HgWiaUb3GPr5ef2nr16IkZtBTTaib1Taa5cqGhYIFd0vtkAe0BHERdJpxU6llrzpAOKZMKOHavZv1AguIczg/640?wx_fmt=png&from=appmsg&watermark=1#imgIndex=1)

当Anthropic把Agent Skills做成开放标准，当OpenAI的Codex和谷歌的智能体平台纷纷入场，大家意识到：**Skill（技能）正在成为全球** **AI** **行业的共识。**

国外很热闹，国内谁先把可复用的经验做成普通人也能用的「技能」？

今天刚升级的扣子正是要回答这个问题。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/UicQ7HgWiaUb3GPr5ef2nr16IkZtBTTaib1tbkQCR4tPtNp7LjUM4uTKLeJqUllic4KdPvTTJx2WSicxZUjFUT3dxMA/640?wx_fmt=png&from=appmsg&watermark=1#imgIndex=2)

此次，它不仅推出了**Skill（技能）、长期任务**，还全球首次上线了**技能商店**。

* Agent Skills （扣子技能）：把你的行业经验装进AI
* Agent Plan（长期计划）：让AI主动服务你
* 技能商店：让技能可以变现交易

**字节扣子2.0首发！AI技能商店来了** ,新智元 ,5分钟 

长期以来，扣子一直在搭生态。而这次它把「能卖、能复用、能长期跑」的能力端上台面。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/UicQ7HgWiaUb3uEdSPKrwGNmZEOaaGyzVvZ8dTtE9jU1rFsda3llYbCZpmWfiazUYjWBLTGvlPpXucH8Q0lEUJN3Q/640?wx_fmt=png&from=appmsg#imgIndex=3)

**Coze Skills**

**当人类经验注入AI智能体**

Coze 2.0不是来聊天的，它是来做事的。

换句话说：扣子想「用Agent重塑生产力」。

最让人兴奋的升级，就是Coze Skill。

如果用一句话定义，Skill就是一个「可复用的工作经验包」。

你把一套经验交给它，它就按固定标准输出。

举个最直观的例子：个人的写作心得完全可以让扣子分析以往的文章，然后一句话生成「个性化写作技能」。

比如，把中意的文章输入到扣子，让扣子分析写作风格。

然后，只要一句话，就能得到个性化的写作技能：

![](https://mmbiz.qpic.cn/sz_mmbiz_gif/UicQ7HgWiaUb3GPr5ef2nr16IkZtBTTaib18iacic1m96M3vBhicibxoJGSWVaJX1RoGaCuKTcdZj8Mw3o63vz4esoghQ/640?wx_fmt=gif&from=appmsg#imgIndex=4)

文章风格技能：https://space.coze.cn/s/ETNki3awR8A/

是的，你没看错，只要一句话——「生成这个风格的写作技能」，扣子自动生成Coze Skill。

在技能商店里看到的「花叔的自动化写作」Coze Skill（https://space.coze.cn/s/UQwCNd\_RDVc/），针对扣子本次更新的一些核心亮点，写了一篇稿件，最后一段写道：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/UicQ7HgWiaUb3GPr5ef2nr16IkZtBTTaib1Ro3Obj2r9Eficq2zEAbqMtmjXjOxjVKkK40aYtr0xC8PibyUODRj5erQ/640?wx_fmt=png&from=appmsg&watermark=1#imgIndex=5)

上下滑动查看

不得不说，这次扣子的确学会讲「人话」了。

这种个人的方法论，以前只能靠你摸索、靠你坚持。现在你只要用几句话描述，它就能被「封装」成一个技能。

然后，任何人都能一键调用。

再举个偏专业的例子：投资知识库。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/UicQ7HgWiaUb3GPr5ef2nr16IkZtBTTaib15ElHybaibmmWy1lNzWibuCiaHBLD8vwC8o4jBEJNiahrsfv4twZP8g4CFg/640?wx_fmt=png&from=appmsg&watermark=1#imgIndex=6)

基于恒生聚源等数据源，「投资知识库」可以让用户一键查询指定A股等数据。

它不只是给你数字。它教你**怎么做多维度分析**。

质变在于：旧的AI用法是让AI通过Prompt去模仿专家；而扣子的方向是让AI直接学会专家的技能，并将其沉淀为一种人人可用的能力。

过去，大模型在学「知识」；现在的Skill，让Agent积累「工作经验」。

这也是扣子敢喊「重塑生产力」的原因之一。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/UicQ7HgWiaUb3uEdSPKrwGNmZEOaaGyzVvZ8dTtE9jU1rFsda3llYbCZpmWfiazUYjWBLTGvlPpXucH8Q0lEUJN3Q/640?wx_fmt=png&from=appmsg#imgIndex=7)

**技能+长期任务**

**扣子让AI从「工具」进化为「同事」**

面对Claude或Codex的Skill，普通人往往止步于复杂的文件结构。

但扣子2.0最让人惊艳的地方在于，**门槛** **极低** **、** **天花板** **极高**。

它对普通人异常友好：你不需要懂任何Agent、Hook或脚本，只需要对它说：「帮我生成这个技能」，它就会结合聊天上下文，**自动为你配好一切**。

比如：

* 按品牌规范自动出文档
* 按公司流程分析数据
* 自动化个人任务（定时、提醒、汇总、投递）
* ……

最终意义只有一句：**你的经验被数字化了。**

如果说Coze Skill解决的是「会不会做」，那么，长期计划解决的就是「能不能做完」。

这是行业内首次发布类似功能。

长期计划是什么？

**扣子称之为「目标导向的** **AI** **协作」**。

你给它一个目标，它会做三件事：

1\. 把模糊目标拆成清晰步骤

2\. 按步骤调用技能和工具去执行

3\. 在关键节点请你确认（Human Check），然后继续跑

你可以把它想象成一个会催进度、会补缺口、会交作业的搭子。

比如你一直想做但没落地的事：

开副业、练口语、健身、整理房间、学习新技能……

长期任务会把「想做」变成「每天做一点」，甚至是 AI帮你每天做一点。

再回到前面的「投资知识库」——关键不在方法论，而在坚持。

有了长期计划，扣子可以像朋友一样，盯着你把这件事做完。

比如，Coze生成了每日AI新闻播报的长期计划。以后，再也不怕漏掉重要的AI新闻。

扣子的最大特点是：你只要表达需求，不必懂Agent、Subagent、Hook、脚本，扣子可以给你一键生成。

它会与你交互，汇报进度。

扣子不再是只会讨好你的回答者，而是一个能真正推进任务的**职场搭子**。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/UicQ7HgWiaUb3uEdSPKrwGNmZEOaaGyzVvZ8dTtE9jU1rFsda3llYbCZpmWfiazUYjWBLTGvlPpXucH8Q0lEUJN3Q/640?wx_fmt=png&from=appmsg#imgIndex=8)

**变现新机会**

**AI时代的「App Store」**

**此次，** **在全球范围内** **，扣子** **首次推出技能商店，其本质是构建一个「经验的交易市场」。**

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/UicQ7HgWiaUb3GPr5ef2nr16IkZtBTTaib1vAicgMXAIRoNd5iawVTztcz76uWzfHmjyO5oMFDes7iaViapYZkqReDxug/640?wx_fmt=jpeg&from=appmsg&watermark=1#imgIndex=9)

在职场中，每个人的专业SOP、行业偏好、甚至是踩坑总结，其实都是极其宝贵的资产。

过去这些经验沉睡在少数人的头脑里，现在通过扣子技能商店，你可以把它们**数字化**。

这直接打开了新的AI经济大门。

你不一定要去公司打卡。

你把Skill挂在技能商店，别人每调用一次，你就赚一次。

以前，扣子的模板商店就有很多开发者赚到了钱。

现在的技能商店，机会更大：

• **专业人士**：可以沉淀行业技能包，供他人一键调用。

• **普通用户**：可以购买或加载「老员工的经验包」，让新人瞬间拥有专业视角。

就像短视频改变了内容行业，**技能商店将改变创意产业**。

创意不再仅仅是视频或梗，而是可以被复用的软件、专业技能和方法论。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/UicQ7HgWiaUb3uEdSPKrwGNmZEOaaGyzVvZ8dTtE9jU1rFsda3llYbCZpmWfiazUYjWBLTGvlPpXucH8Q0lEUJN3Q/640?wx_fmt=png&from=appmsg#imgIndex=10)

****Vibe三部曲**

 **Coding、Agent、Skills**

事实上，这次升级的技能也好，长期任务也好，本质上依靠的是Vibe Agent能力，而Vibe Agent又基于扣子在Vibe Coding上的积累。

只要你有需求，你需要一句话，你的要求、你的目标、你的计划，扣子通通理解，一键生成智能体、工作流、Web、App、技能。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/UicQ7HgWiaUb3GPr5ef2nr16IkZtBTTaib1KYOx2lxjldX0UCibJiajEAPI5tTqkmWsxeuF9oJFp2icFav8icJlnInPicA/640?wx_fmt=png&from=appmsg&watermark=1#imgIndex=11)

编程是智能体改变的第一个领域，也是AI学会使用的第一个工具。

扣子编程是扣子的来时路，也是扣子「元能力」、核心中的核心。

据介绍，扣子**已帮助用户走完了最后一公里。**

此前的Vibe Coding的确可以让产品跑起来，但这并不是软件的终点。

传统软件开发生命周期（SDLC）大致分6大步：

目标与需求 → 设计 → 编码 → 测试 → 部署 → 维护

实际上，在传统的软件工程中，代码实现前以及之前的阶段只占软件生命周期的一小部分，之后的测试、部署和维护等阶段才占大头。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/UicQ7HgWiaUb3GPr5ef2nr16IkZtBTTaib1cMaKWRj0a74v2aKD8ibZicniaa6u5KgNszU24nHTnnjvtk7YHRXWcpRYQ/640?wx_fmt=png&from=appmsg&watermark=1#imgIndex=12)

如果希望软件能够产生收益、产生价值、稳定运行，是需要持续部署和持续迭代、持续运维。这些工作还需依赖一个懂部署、懂运维的工程师。

扣子这次提出了「Vibe Infra」的概念，核心目标是**构建一套真正面向所有开发者的编程生态。**

基于字节在云计算领域强大的基础设施，扣子提供了一套从开发到部署的全套基础设施服务，包含了**服务器的资源分配、应用的版本部署，域名备案配置，甚至包括** **iOS** **和安卓的版本发布。**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/UicQ7HgWiaUb3uEdSPKrwGNmZEOaaGyzVvZ8dTtE9jU1rFsda3llYbCZpmWfiazUYjWBLTGvlPpXucH8Q0lEUJN3Q/640?wx_fmt=png&from=appmsg#imgIndex=13)

**解放的不止是生产力**

汽车取代马车、打印机取代铅字印刷……

历史上，技术创新不断惠及更多普通人。

计算机也不例外。

世界上第一台通用计算机ENIAC，重量达27吨，体积大约是2.4m×6m×30.48m，占地167平方米，耗电150千瓦。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/UicQ7HgWiaUb3GPr5ef2nr16IkZtBTTaib1pqJ6qQqSa9aegUuo0HPZVfg4UPZCF51EkLJFsENe37pnICsX4ib4bHw/640?wx_fmt=png&from=appmsg&watermark=1#imgIndex=14)

而它每秒大约可进行5000次简单加减操作，不及现在最普通的手机。

在那个时代，几乎没人能相信，50年后几亿人手掌上的设备就有如此强大的计算能力。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/UicQ7HgWiaUb3GPr5ef2nr16IkZtBTTaib10Tqthe9MiayWFPhprCKFcmC3RhzRgK4wmMkUic0vLXiaXZjpCNSDicNdMQ/640?wx_fmt=png&from=appmsg&watermark=1#imgIndex=15)

而那些当年在打孔卡上「手搓」计算机程序的开发者，也很难相信，现在只有描述需求，机器就能生成可用的代码了。

这或许是AI编程的历史意义。

而我们也很难想象，扣子2.0将带来怎么样的新的未来职场。

据介绍，扣子更在意的是协作关系，他们对未来的设想是：

你不再是使用一款工具， 而是和一个能真正推进任务的AI伙伴一起工作。

你的精力应该花在策略、思考、创造上，执行、迭代、收尾这些事，都可以交给扣子。

而且扣子2.0不仅速度更快、思考更深入，而且更聚焦职场痛点。

扣子2.0不泛泛而谈，而是深入分析和挖掘，给你更本质更专业的适配你的回答，更适合在严肃的职场环境中使用。

，时长00:40

作为靠谱的的工作伙伴，扣子2.0不是「能生成点东西」，而是能交付「能被拿去用」的成品。

除了以上这些功能，扣子2.0还有更多惊喜👇。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/UicQ7HgWiaUb3uEdSPKrwGNmZEOaaGyzVvZ8dTtE9jU1rFsda3llYbCZpmWfiazUYjWBLTGvlPpXucH8Q0lEUJN3Q/640?wx_fmt=png&from=appmsg#imgIndex=16)

**One More Thing**

此外，这次扣子首次推出视频Agent SKill。

扣子视频技能正式开始公测。

它搭载字节旗舰视频 / 生图 / 声音模型，5分钟即可呈现音画同出的1-2min创意视频，并支持输入参考图、视频文件来进行参考生成。

比如，扣子2.0用水墨画风格展示的国内城市地标：

，时长00:42

不仅如此，扣子视频技能的视频编辑功能也超级好用。

打开视频编辑器，扣子会将所有抽卡所用的提示词、图片素材，原封不动地还给你，并在编辑器内支持重新生成、裁剪、延长片段的能力，大大提升你二次编辑的效率。

![](https://mmbiz.qpic.cn/sz_mmbiz_gif/UicQ7HgWiaUb3GPr5ef2nr16IkZtBTTaib1SfEJFp0LdKOOgia2YqmdvuwPUC37nZOksUle9EjZQDjgia9ic1ZxYsa4A/640?wx_fmt=gif&from=appmsg#imgIndex=17)

分镜图也支持导入历史生成的素材图，进行参考后二次生成，在修改角色的场景很方便。

在完成粗剪之后，还支持导入到剪映，轻松进入精剪环节。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/UicQ7HgWiaUb3GPr5ef2nr16IkZtBTTaib1Ee2uPLCQkOJIOCazJfShicXa5bTHbnKbooeaRWp4HGZ0F2Ey27uWZvA/640?wx_fmt=png&from=appmsg&watermark=1#imgIndex=18)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/UicQ7HgWiaUb3GPr5ef2nr16IkZtBTTaib1JuNPBlVcIQ7eoxmDjvlw6eBo6UzicxJiapZf6LOMYqfXwqboHXvReJzw/640?wx_fmt=png&from=appmsg&watermark=1#imgIndex=19)

上下滑动查看

重要的是，现在扣子做一个1min视频的成本，可能只有海外同类型产品的1/50。

参考资料：

https://space.coze.cn/skills

**秒追ASI**

**⭐点赞、转发、在看一键三连⭐**

**点亮星标，锁定新智元极速推送！**

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/UicQ7HgWiaUb3kx5KHMlrHP7uvWown7E5ibwUVozEDQYdZRVypXCGR5V5EXrlniajAzKLR3hWN5pDDUibX9ud49ouicQ/640?wx_fmt=jpeg&from=appmsg&watermark=1&tp=webp&wxfrom=5&wx_lazy=1)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/UicQ7HgWiaUb3kx5KHMlrHP7uvWown7E5ibEukSibyRZ1XHK7BsP7y0lCOibia4ozGlGoq6N1DOTbOmZIWsZlMsnyqXQ/640?wx_fmt=jpeg&from=appmsg&watermark=1&tp=webp&wxfrom=5&wx_lazy=1)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/UicQ7HgWiaUb3kx5KHMlrHP7uvWown7E5ibE1Yejh1DOMCkIqNnpMCvqs7sUFhTWj8P1HSGUib4OdF0xmeKpjLA49A/640?wx_fmt=jpeg&from=appmsg&watermark=1#imgIndex=22)

hidden text to trigger resize events if fonts change

---

# [五条0114] Gemini 新增 Auto Browse，浏览器变身 AI 助理
发布日期：2026/01/13

![](https://www.testingcatalog.com/content/images/size/w2000/2026/01/Google-Gemini-01-13-2026_01_13_AM.jpg)

Google is preparing to introduce a new “Auto Browse” capability for Gemini, now appearing under the tools section with a cursor icon but not yet available publicly. The design and placement of this feature suggest it is aimed at enabling Gemini to autonomously browse the web, manage tabs, and directly interact with Chrome on the user’s behalf. This approach closely follows agentic trends established by platforms like [Perplexity Comet](https://www.testingcatalog.com/perplexity-launches-comet-ai-browser-worldwide-for-free/) and [OpenAI Atlas](https://www.testingcatalog.com/chatgpt-launches-agentic-ai-browser-atlas-for-macos/), where users can delegate complex browsing and information retrieval tasks to AI agents. The presence of checks verifying whether Gemini is running inside a Chrome extension further points to a sidebar integration, allowing for seamless control without leaving the Gemini interface.

The Auto Browse tool was recently added to Gemini’s internal toolset, indicating accelerated development following the [initial release of Chrome agentic features](https://blog.google/products-and-platforms/products/chrome/new-ai-features-for-chrome/?ref=testingcatalog.com) last September, which at that stage reached only a limited audience in the US. These moves align with Google’s broader strategy to close the feature gap with competing AI-powered assistants and to extend Gemini’s reach beyond conventional chat or search. For users, this could mean managing browsing sessions, researching topics, or executing workflows within Chrome, all orchestrated by [Gemini](https://www.testingcatalog.com/tag/gemini/).

Code references indicate that Auto Browse may become exclusive to the Gemini Ultra plan, positioning it as a premium capability. If rolled out as expected, this feature will likely serve professionals and power users who need to automate research or web-based tasks, marking a notable step towards a more agent-driven web experience. Google’s timing and incremental rollout also reflect the company’s intent to test and refine these features before expanding access, which suggests a wider release may follow soon.

hidden text to trigger resize events if fonts change

---

# [五条0115] 千问App大更新：AI帮你搞定吃穿住行
发布日期：2026/01/15

> 我有，你没有。

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOfYrHccibyOIibmdgvT4qFRhoHtEEIaP5cWZOCiacoED13jHuVRg5HjEgQ/640?wx_fmt=other&from=appmsg#imgIndex=0)

👦🏻 作者: 镜山

🥷 编辑: Koji

🧑‍🎨 排版: NCon

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOZibDerVSzNaJ3EBJ8bAJpdiaKVtC7Qj9TbGG8nSFbX0ANnibDXpib001Lw/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1)

最近，大洋彼岸传来一条令大家都很关注消息：Google 宣布，旗下的 Gemini 正在与全球零售巨头沃尔玛展开更深层的整合，还发布了全新的 AI 购物协议 UCP。

在谷歌眼里，AI 不再只是一个负责「回答问题」的对话框。

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbO0FrOJGqJzVqTusWiaHpCjVCaHaOeTpMRVrMsoEfSTVwF1ibuibWAib41PA/640?wx_fmt=other&from=appmsg#imgIndex=2)

最近，阿里旗下的千问 App 也同样针对这样的「真实任务」场景 进行了一次关键更新。

我们注意到，它已经打通了淘宝、高德、飞猪、支付宝等一系列底层服务接口。换句话说，它不仅接入了阿里的模型能力，还直接连上了这个生态里最核心、也最高频的生活与交易系统。

### 🚥

为此，我们做了一次相对深入的实测，想看看一个尝试做「懂生活、能行动」的 AI 入口，究竟已经走到了哪一步。

## AI 是如何通过打通生态，来处理「真实场景」的？

这回千问 App 的更新，大概都做了什么？

这次更新并不花哨，真正的变化集中在两个点上：一是上线了一个新的「办公助理」模块，二是更深度地接入了阿里内部的一整套生态能力：包括淘宝、闪购、飞猪、高德和支付宝。

先说「办公助理」。它被单独放在了一个明确的入口里，定位也很清晰：主要负责那些链路更长、步骤更复杂的任务。

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOFhNw5EiaY3j6PCUiamRIqOVe7ZI1jbA9osMd39R9FXPoHJ4tcwibxtw2A/640?wx_fmt=other&from=appmsg#imgIndex=3)

另一个变化的入口则要轻量得多，也更符合大多数人的直觉使用习惯，在千问 App 的主页面，直接对话就可以触发相关能力。

这两个入口都接入了阿里的完整生态。

你可以试着在千问 App 的主页上随机执行一些指令。你会发现，一旦涉及阿里生态内部的联动，系统就会触发一个逻辑前提：绑定淘宝账号。

比如你想直接通过它点外卖，系统会提示你先完成账号关联。

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOWibyyPW559ZCdOiaOLVytoQibd4YkjKkSRhm5f8GC2IPHuE6Liania0duDg/640?wx_fmt=other&from=appmsg#imgIndex=4)

## 1）帮我点杯奶茶 / 吉野家

我们可以从一个更轻量的入口开始体验：在千问 App 的主页面，直接用自然语言提问就行。比如你可以让它帮你点一杯奶茶，或者点一份吉野家的照烧鸡排饭。

接下来你会发现，它会自动读取并连通你的淘宝地址体系，让你选择一个外卖接收地址，也就是淘宝闪购对应的配送地址。

地址确认之后，千问会跳转到目标商家，自动帮你定位到对应的商品，并以商品卡片的形式展示出来。

在这个过程中，你还可以继续补充需求。比如已经选好一杯奶茶后，你可以再说明不额外加糖，或者更偏好含咖啡因的口味，它会基于这些条件重新筛选并调整结果。

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbObAHp440kHMsvw3IbB0icP6L0cI0uqdwib3icPv50lwQia3mc3LOgGvEXHQ/640?wx_fmt=other&from=appmsg#imgIndex=5)

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOgLy2WWJ9kAt4pkiachXOuJ6NuibNQhufoIDnXYlvE5QnicAserWmTCBWg/640?wx_fmt=other&from=appmsg#imgIndex=6)

一个比较细节的点是，在走淘宝闪购流程时，它会顺带帮你匹配可用的优惠信息，把折扣一起算进来。

它给出的这些商品卡片，本质上是和淘宝闪购的商品数据深度连通的。你点进卡片之后，可以像在原生外卖页面里一样继续操作。

比如，你可以直接在卡片里修改商品配置，切换不同的规格或口味，增加配料，甚至再顺手点几样同店的其他商品：

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOLl3ia0iay4IJVp9bic3urNTfuweU7DWYnkh7U4cqBPdwrDTdcU5icJtF2Q/640?wx_fmt=other&from=appmsg#imgIndex=7)

## 2）打通淘宝

当然，能力并不只停留在淘宝闪购这一层。千问已经接入了阿里体系下的多个核心平台，包括淘宝，很多场景都可以在同一个对话里完成衔接。

比如，让它去淘宝看下空调，输入提示词：
  
  
帮我看看淘宝上，有没有性价比高点的空调

现在的千问会先去调查网上关于空调性价比的各种评论，然后整理出一个结构化的回答，里面嵌入了淘宝的商品卡片：

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOscdDceczaOyb3DkTzbSMdmw52OiaNkuZtqncwjRv7lz0z6eGCTuvVlw/640?wx_fmt=other&from=appmsg#imgIndex=8)

而且，在这份回答里，还给出了一个表格化的总结，点击这些商品卡片的话，会跳转到浏览相关商品的商品框里：

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOJtRh3ttEQ6iaDg1kRHD7SpcsSTzLyfia1jRQSeFDic7KMuiaB4aRX6zBKw/640?wx_fmt=other&from=appmsg#imgIndex=9)

我还发现，我可以直接上传小红书上被种草的图片，直接给它，然后它就能直接进行画面识别，再去淘宝上搜索到相关结果：

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbO73KLYJFlZeTN2cia6fhgVK1X7oIibr4Hibbm9SqXb7XmxiczGd9vcOlqsw/640?wx_fmt=other&from=appmsg#imgIndex=10)

## 3）「复杂」任务场景

前面提到的这一两个例子，其实都属于比较基础的生态联通场景，更多是在验证千问如何把现有的平台能力顺畅地接进一次对话流程里。

如果想体验更复杂一些的任务场景，可以换一个入口，从千问的「办公助手」进入。

这里覆盖的通常是多步骤、强规划型的需求，对 AI 的理解、拆解和调用能力要求也会更高。

像是：
  
  
帮我点 20 份吉野家套餐，作为我们团队的工作餐，鸡肉、牛肉的都要，再来点饮料

进入「办公助手」之后，整体反馈方式会更接近你在 AI chatbot 里做深度任务时的体验。它会先确认你的核心需求，并自动结合已有的信息，比如配送地址，然后再一步步把任务往下拆解。

在这个过程中，它会主动追问关键细节，确保后续操作不会出错。

比如我一次性点了 20 份吉野家的套餐，它就会继续确认鸡肉和牛肉各需要多少份、饮料是否需要搭配、数量如何分配：

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOtnFaOSbqJYrdicfrC36wkC2ic65GhQicpVwnicxibia9YhzTgZMWXEDHeeZA/640?wx_fmt=other&from=appmsg#imgIndex=11)

当这些需求逐一确认完成后，你会发现它背后的工作流被展示得相当清晰。

比如，它会先基于你的地址去匹配周边可用的商家范围，像幸运咖、吉野家这类符合条件的门店都会被纳入候选。

接着，再在这些商家内部继续做商品层面的搜索和筛选：

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbO0Vmykp5WAMyNlvRQRRmH4LHkQibPibyGEiasr8iawFtQtGhnZL8RSEny2g/640?wx_fmt=other&from=appmsg#imgIndex=12)

最终，它会基于前面所有确认过的信息，给出一份能够覆盖 20 份餐食需求的完整方案。

在我的体验里，它会同时给出三种不同的组合方案，每一份方案都会在侧重点上有不同：

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOrqiblZaerzkVmSxk9Rc60ibzON9UfsiaRQbxuwIa0UrIA1K5FqS51GvrQ/640?wx_fmt=other&from=appmsg#imgIndex=13)

每一份方案本身都是可继续操作的。你既可以直接选择其中一个完成付款，也可以在方案基础上再做调整，比如改动商品组合或数量。

同时，它还会在后台自动帮你匹配可用的优惠信息，把折扣一并算进去。

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbO4Lk8kDPk3wyyvXIcyXB2aS0rD1BqTYicf8yu53skQLtwyGmjGicsDiarQ/640?wx_fmt=other&from=appmsg#imgIndex=14)

## 4）吃穿住行的大闭环

除了外卖这种相对高频、即时的场景之外，我还注意到它在更长链路的任务上同样成立，比如一句话就让 AI 去定制一整套旅行的吃、住、行安排。

这类体验整体下来会更完整，也更有“闭环感”。

举个例子，如果你只是告诉它，想带爸妈来北京玩一趟，再简单补充一些需求偏好，它就可以围绕这个目标开始做整体规划，把行程、住宿、出行方式以及用餐选择逐步串联起来。

提示词如下：
  
  
我爸妈 60 多岁，第一次来北京，不想走太多路、不排队、不折腾，帮我规划 3 天游玩和住宿。

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOKozv0icFgFSxCIMgkkfHoGGs9vujvgz9gLkcHcuc7q0ia9ib2lJLzUcPg/640?wx_fmt=other&from=appmsg#imgIndex=15)

在我提出这个需求之后，它会继续和我交互，逐步把关键信息补齐。

在这样一个复杂闭环的任务里，它的执行逻辑会变得非常清晰。举例来说，它会先结合我父母的年龄，去整理适合带父母在北京游玩的思路和注意事项，这部分信息主要来自各类公开网站。

随后，再调用高德地图，去核对从上海到北京的出行方式，包括高铁、飞机以及对应的站点或机场安排。

在此基础上，才会继续生成类似「北京 3 日游」这样的行程结构，把吃、住、行逐步填充进去。

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbO48TrIB7XE7H7Qfq6NjXAzbSlFZvDCmdDwwax2zMuMOCuknSN1ue75A/640?wx_fmt=other&from=appmsg#imgIndex=16)

在前面这些基础步骤完成之后，它还会继续往下推进，调用飞猪去细化「具体玩什么」的问题。这个阶段会进入到更细的游览层级。

比如在故宫博物馆的场景下，它会进一步拆分到午门、珍宝馆等具体参观点：

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOianQtzdTEddibTmnq2FRiauwicRkQ8PiakHglFejpk8v5TAyEeJGm05PJiaw/640?wx_fmt=other&from=appmsg#imgIndex=17)

最终呈现出来的结果，会更接近一份结构化的页面，而不是零散的对话回复。整体形式有点像一个 HTML 网页，把所有规划内容集中在一起展示。

在这份详细的旅行规划中，会包含一个地图卡片，规划好了三条不同的路线：

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbO49RBx14B4smAI08kP8VVdAm7icWV5UFkr659IrlD6ic5h6sTcjK1SSNA/640?wx_fmt=other&from=appmsg#imgIndex=18)

当然，作为一份完整的攻略，交通信息也被自然地整合进来了。比如从上海到北京的出行方案，会直接给出对应的航班信息，包含时间、班次等要素。

如果你在这个页面里点击购票相关的选项，它会直接跳转到真实可用的机票购买页面：

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOz85rfGcNGxW2exL9EpJLBr07b2J3fiaE2tcVbYXh7Yzyl4cUWibWMJyA/640?wx_fmt=other&from=appmsg#imgIndex=19)

另外，在这份完整的页面里，我还注意到一个比较细节的设计。很多景点条目下面，其实都会配有一些功能模块，比如导航、打车详情之类。可以直接点进去使用的。

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOTEkvwyTC88eImw2zAjdkqiaghycwFJuMicTmibAGxVHwnDNLvXbBpibpUg/640?wx_fmt=other&from=appmsg#imgIndex=20)

比如，当我点开其中的「导航」功能时，它会直接跳转到高德地图，路线已经提前帮我设定好了。如果是涉及门票的场景，也可以顺着入口进入对应的购票页面。

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOWfMyXDUu4W9s1bicMniaCLHGFia5vEm0VvrSlNxjoFO6JIicobm1INblWQ/640?wx_fmt=other&from=appmsg#imgIndex=21)

住宿这一块其实给人的感觉也挺顺的。它会直接在行程里帮你列出几种不同的住宿方案，有近一点的，也有性价比高一点的，选择面不会太窄。

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbO32lr0Dth9NXhToL1ibDUDkQnibvGYhdx2iazuYTBV4sloxln0Q9UJtEicQ/640?wx_fmt=other&from=appmsg#imgIndex=22)

下面是这个完整任务的录屏，我已经放在下方了，可以整体看一遍，过程做了加速处理：

，时长00:31

## 5）复杂的办公场景

现在的千问 App，在这两个入口下，对相对复杂的图片解析能力表现得会更成熟一些，也已经和这次升级的核心能力打通了。

比如，我可以直接上传一张信息密度很高的图片。

前段时间我试过一张 2026 年 1 月 14 日 NBA 比赛的伤停名单，图片本身非常复杂：

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOcckHq75dibnTtCSNathibneG1OP6dofa0s82jXVKa54KG1mPOyZC3zYQ/640?wx_fmt=other&from=appmsg#imgIndex=23)

然后在「办公助理」这个入口里，你可以直接用一句话让它把事情做完。比如让它基于这张图片，先完成信息识别，再整理成一份完整的 Excel 表格。

在这个基础上，它还可以进一步把结果做成一个可视化的 HTML 页面：

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOoYNLvWaFqoqwQUbGhr0ksgWCKDibz4gQfICCicZ064afszFN664C7VdQ/640?wx_fmt=other&from=appmsg#imgIndex=24)

最终给出的结果，其实完成度相当高，是一份具备完整交互能力的可视化报告。我截了几张图放在下面，可以直观看到它把不同层次的内容都整合到了一起：

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOHCqslSUrHuZBHZL6ibCwHhN0jf4XOibDA1ryibEUNQdr8GjeeibWgMpxPw/640?wx_fmt=other&from=appmsg#imgIndex=25)

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOJFBiaQ9icQc9SrE3icH4VX4ICuvNaqpzics6iada3oy6ksgwcrke0ffiamkA/640?wx_fmt=other&from=appmsg#imgIndex=26)

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOpSTby4ib5opsib3IjicIibmvPVJ2wO6ibH9CdO7Nh3Mia1MPvGNr2G6taicFQ/640?wx_fmt=other&from=appmsg#imgIndex=27)

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbO9wY4uVSiaicW9B2KKVKl9v5Hl2nc3JvibWq2ibuYoUQXpohphurfvTn9Vw/640?wx_fmt=other&from=appmsg#imgIndex=28)

里面有结构化的数据表格，也有对应的数量统计和状态分布的环状图，甚至还生成了一个可以拖拽查看的 3D 数据可视化，已经算是非常成熟了。

### 🚥

过去很多年里，人和系统的关系是「你去适应工具」。我们在手机里装满 App，记住每个入口的位置，按既定流程一步步点完。

而在 AI 时代所呈现出来的逻辑，将会反过来：用户不需要理解系统结构，只需要清楚表达自己的「意图（Intent）」，剩下的「行动（Action）」交给 AI 去完成。

你不必关心先打开哪个 App、再跳转到哪一步。系统结构被压缩到后台，对用户来说，只剩下一次自然的表达。

而目前，推动这个趋势往前走的还是 AI 入口背后的生态。阿里生态的优势，在这里被放大得很明显，它背后连接的是真实、密集、高频的生活系统。

客观地说，千问这次更新仍然处在邀测和灰度阶段，距离成熟形态还有不少打磨空间。

但它已经表示出一个方向：AI 的角色，正在从工具型应用向统一入口转变。

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOGEWCpGau3iaRAjczcGUX8gia18Ag5jeVicyfXEt09RpOBhWicKo4VW0HtQ/640?wx_fmt=other&from=appmsg#imgIndex=29)

![](https://mmbiz.qpic.cn/mmbiz_jpg/FFcNSoQ3Kicu9N5g3FSR7LopEGdtibBHbOyhK1QqSclYf3ZneZ33KGkTLjmEicGqe8otZpia6N2KC7DTdGPwrGjnvA/640?wx_fmt=other&from=appmsg#imgIndex=30)

hidden text to trigger resize events if fonts change

---

# [五条0119] 谷歌Gemini设计揭秘：如何让AI更可信？
发布日期：2026/01/19

How do you build trust in a tool that’s always evolving? Our AI assistant, Gemini, is constantly learning and adapting, which means traditional design methodologies (mostly linear, predictable, and rooted in control) have to be set aside.

Our designers took on the challenge of charting a new digital landscape. How do you bridge conceptual gaps around AI, especially around how Gemini simplifies information and expands ideas? How do you invite users to explore, play, and search, so they can build confidence using an ever-shifting tool? These questions were guided by a core set of goals: to make Gemini feel intuitive, immersive, approachable, aspirational — and, above all, trustworthy.

While Gemini’s [sparkle icon](https://design.google/library/ai-sparkle-icon-research-pozos-schmidt) may be the most ubiquitous visual element within the Gemini brand, there are many other elements of the product’s illustration system to be explored. In this deep dive, the designers behind the system pull back the curtain to reveal gradients, responsive containers, and intentional motion that seamlessly work together to create a sense of magic, clarity, and familiarity within the Gemini experience.

Navigating uncharted design territory isn’t new. Consider designer Susan Kare, who pioneered the original Macintosh interface. Using simple visual metaphors, she made abstract digital processes tangible and intuitive for new users: a trash can, a paintbrush, a smiling computer face. Her icons weren’t just pixels; they were bridges between human understanding and machine logic. Gemini faces a similar challenge around accessibility, visibility, and alleviating potential concerns. What is Gemini’s equivalent of Kare’s smiling computer face?

The design team landed on gradients, which gently guide users into the new collaborative world with Gemini. It’s an amorphous, adaptable approach, unlike the static nature of past digital assistants (many of us remember Microsoft’s Clippy), yet it inspires a similar sense of discoverability. Gradients might be much more about energy than “objectness,” like Kare’s illustrations (a trash can is a thing, a gradient is a vibe), but they infuse a spirit and directionality into Gemini.

A solid blue pill shape centered on a vertical line representing a pressed power button state. A soft, diffused blue gradient glowing from a power button icon, suggesting an active, energized state. A solid green curved shape nestled in the bottom-left corner of a frame, indicating a swipe gesture. A vibrant, multi-colored blurred shape pulsing from a corner, representing an active swipe-to-activate gesture.

Simple sequences were explored to guide users toward activating Gemini. These included pressing and holding the power button or swiping from a corner.

Gradients are central to Gemini’s visual storytelling, acting as context builders that guide users through the product experience. Designed to convey a transfer of energy and directional momentum, they feature sharp, almost opaque leading edges that diffuse at the tail, acting as clear visual pointers to direct user attention toward what’s most important.

To make the system feel alive, our designers wanted to visualize Gemini’s process of active thinking and synthesis, which helps personify the AI assistant rather than rendering it impenetrable.

Gemini’s visual language needed to support its own identity while integrating with Google’s existing aesthetic. The design team looked to the company’s familiar logo for inspiration, focusing on the fundamental shape of the circle. This choice was deliberate, as circles tend to convey simplicity, harmony, and comfort. Even Gemini’s own logo is thoughtfully constructed from the negative space of four adjoining circles.

We explored several foundational shapes to represent Gemini’s “thinking state,” drawing heavily from Google’s design heritage. We experimented with the iconic four-color dots — a symbol of the brand’s rounded, optimistic language — and various Material shapes historically tied to voice and Android’s system UI. By leveraging these established elements, we were able to ground the new framework in a familiar history while ultimately evolving them into a more dynamic, fluid expression of AI intelligence.

Many of Gemini’s interface elements, such as buttons and containers, echo the circle through their rounded corners. These subtle visual cues bring continuity with other Google applications. But perhaps the most impactful use of the circle is how it contains and sculpts Gemini’s signature color gradients. Here, shape acts as a dynamic vessel, concentrating energy into a sharp point before allowing it to blossom outwards—a visual metaphor for Gemini’s ability to process and expand ideas.

People expect consistency from digital systems; they want to learn once and apply that knowledge repeatedly. The challenge for the Gemini illustration team has been to cut through that dynamism, creating a new, yet familiar, visual language.

The illustrations are meant to have a “warm, spatial, rounded quality,” says Anna Sera Garcia, design lead. “We’re always considering how to depict our UI in a way that feels optimistic, delightful, playful, yet also sophisticated. There’s something ethereal — that kind of in-between fuzzy space that reflects our nonlinear process for ideation.” The aim was to make sure the illustrations felt intuitive and frictionless, which is crucial for a product like Gemini that’s so new, revolutionary, and always changing.

Movement in Gemini is not merely decorative; it’s an essential guiding element. Each animation has a defined start and end point, creating a sense of directional flow that mirrors user actions. This sense of responsiveness helps users intuitively understand that the system is working with them. Inner activity within the motion conveys thinking, analysis, and intelligence, making Gemini’s processing feel more transparent. Motion allows users to see information coming together, visualizing Gemini’s conversations and listening abilities.

“Whether it’s introducing haptics or subtle shifts in how we communicate, the aim is to make the interaction feel easy and intuitive for users,” says Garcia. “It’s interesting to look back at how technology has shaped the ways we converse and learn. We’re trying to unlock those foundational principles that feel intuitive for this new set of interactions.” These principles work as context builders where one thing leads to the next, helping users feel guided rather than lost.

## Embracing softness in the face of change

Gemini’s solutions feel cool, calm, and considered, by concealing the struggles and challenges of their creation. Garcia notes, “There’s a sense of play and camaraderie that happens when brainstorming, knowing deliverables will change.” Our onboarding illustrations are constantly being refined, building on the elements that already exist.

This process highlights the importance of a foundational experience that forgives mistakes, anticipates confusion, and invites exploration. When a system is hard to approach, the design must be soft. This softness — conveyed through guided, pulsing gradient shapes, clear language, and transparent signaling — allows users to engage with the new system feeling secure and supported. The gradient can be many things through its animations: aspirational and uplifting, directional and instructional. But they remain soft and direct, and always looking forward; they’re deeply connected to the Google brand with room to grow, like the personified gradient, rippling and responding to voice.

## The designer as cartographer

Designing illustrations for Gemini is like charting a continuously evolving map. Designers aren’t creating a fixed tool; they’re rigorously composing a relational experience that adapts as much as it informs. How do you build trust with a tool that won’t look the same tomorrow? The user doesn’t need the system to be perfect. They need it to be thoughtfully imperfect — and this, now, is the designer’s job, as we move into future evolutions of Gemini.

_Special thanks to Buck, our creative partner and agency, Ivan Witteborg, Namroac Doan and Andy Stewart for their contributions to this work._

hidden text to trigger resize events if fonts change